package com.inventory.service;

import com.inventory.dto.response.DashboardResponse;
import com.inventory.dto.response.DashboardResponse.ProductPieChartData;
import com.inventory.entity.Product;
import com.inventory.entity.SalesOrder;
import com.inventory.entity.User;
import com.inventory.repository.ProductRepository;
import com.inventory.repository.SalesOrderRepository;
import com.inventory.security.SecurityUtils;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class DashboardService {

    private final ProductRepository products;
    private final SalesOrderRepository salesOrders;
    private final SecurityUtils securityUtils;

    @Transactional(readOnly = true)
    public DashboardResponse getDashboard(String range) {
        DashboardResponse.InventoryMetrics inv = buildInventoryMetrics();
        DashboardResponse.SalesMetrics sales = buildSalesMetrics();
        List<DashboardResponse.LowStockItem> lowStock = buildLowStockList();
        List<DashboardResponse.RecentOrder> recent = buildRecentOrders();
        List<DashboardResponse.ChartData> chartData = buildChartData(range);
        List<DashboardResponse.PieChartData> pieData = buildPieChartData();
        List<ProductPieChartData> productSales = buildProductSalesData();
        List<ProductPieChartData> underPerforming = buildUnderPerformingData(); // <--- NEW

        return DashboardResponse.builder()
                .inventoryMetrics(inv)
                .salesMetrics(sales)
                .lowStockItems(lowStock)
                .recentOrders(recent)
                .salesChart(chartData)
                .departmentSales(pieData)
                .productSales(productSales)
                .underPerformingProducts(underPerforming) // <--- NEW
                .build();
    }

    private List<ProductPieChartData> buildProductSalesData() {
        return salesOrders.findTopSellingProducts().stream()
                .map(this::mapToPieData)
                .collect(Collectors.toList());
    }

    // --- NEW METHOD ---
    private List<ProductPieChartData> buildUnderPerformingData() {
        return salesOrders.findLeastSellingProducts().stream()
                .map(this::mapToPieData)
                .collect(Collectors.toList());
    }

    private ProductPieChartData mapToPieData(Object[] row) {
        return ProductPieChartData.builder()
                .productName(row[0] != null ? row[0].toString() : "Unknown")
                .totalSold(((Number) row[1]).longValue())
                .build();
    }

    private DashboardResponse.InventoryMetrics buildInventoryMetrics() {
        User user = securityUtils.getCurrentUser();
        boolean isStaff = user.getRole().getName().equals("INVENTORY_STAFF");
        String dept = user.getDepartment();

        int totalProducts;
        int totalQty;
        int outOfStock;
        BigDecimal totalValue;
        Integer lowStockCount;

        if (isStaff && dept != null && !dept.isEmpty()) {
            List<Product> deptProducts = products.findByCategoryName(dept, Pageable.unpaged()).getContent();
            totalProducts = deptProducts.size();
            totalQty = deptProducts.stream().mapToInt(p -> p.getQuantityOnHand() == null ? 0 : p.getQuantityOnHand()).sum();
            outOfStock = (int) deptProducts.stream().filter(p -> (p.getQuantityOnHand() == null ? 0 : p.getQuantityOnHand()) == 0).count();
            totalValue = products.calculateTotalInventoryValueByDept(dept);
            lowStockCount = products.countLowStockProductsByDept(dept);
        } else {
            List<Product> all = products.findByIsActiveTrue();
            totalProducts = all.size();
            totalQty = all.stream().mapToInt(p -> p.getQuantityOnHand() == null ? 0 : p.getQuantityOnHand()).sum();
            outOfStock = (int) all.stream().filter(p -> (p.getQuantityOnHand() == null ? 0 : p.getQuantityOnHand()) == 0).count();
            totalValue = products.calculateTotalInventoryValue();
            lowStockCount = products.countLowStockProducts();
        }

        if (totalValue == null) totalValue = BigDecimal.ZERO;
        if (lowStockCount == null) lowStockCount = 0;

        return DashboardResponse.InventoryMetrics.builder()
                .totalProducts(totalProducts)
                .totalQuantity(totalQty)
                .totalInventoryValue(totalValue)
                .lowStockCount(lowStockCount)
                .outOfStockCount(outOfStock)
                .build();
    }

    private List<DashboardResponse.ChartData> buildChartData(String range) {
        LocalDateTime startDate = switch (range.toLowerCase()) {
            case "week" -> LocalDateTime.now().minusWeeks(1);
            case "month" -> LocalDateTime.now().minusMonths(1);
            case "year" -> LocalDateTime.now().minusYears(1);
            default -> LocalDateTime.now().minusDays(1);
        };

        List<Object[]> results;
        if ("year".equalsIgnoreCase(range)) {
            results = salesOrders.findSalesStatsByMonth(startDate);
            return results.stream().map(row -> {
                int y = ((Number) row[0]).intValue();
                int m = ((Number) row[1]).intValue();
                String dateKey = String.format("%d-%02d", y, m);
                return DashboardResponse.ChartData.builder()
                        .date(dateKey)
                        .orderCount(((Number) row[2]).intValue())
                        .revenue((BigDecimal) row[3])
                        .build();
            }).collect(Collectors.toList());
        } else {
            results = salesOrders.findSalesStatsByDateRange(startDate);
            return results.stream().map(row -> DashboardResponse.ChartData.builder()
                    .date(row[0].toString())
                    .orderCount(((Number) row[1]).intValue())
                    .revenue((BigDecimal) row[2])
                    .build()
            ).collect(Collectors.toList());
        }
    }

    private List<DashboardResponse.PieChartData> buildPieChartData() {
        List<Object[]> results = salesOrders.findSalesByDepartment();
        return results.stream().map(row -> DashboardResponse.PieChartData.builder()
                .name(row[0] != null ? row[0].toString() : "Unassigned")
                .value((BigDecimal) row[1])
                .build()
        ).collect(Collectors.toList());
    }

    private DashboardResponse.SalesMetrics buildSalesMetrics() {
        LocalDateTime startOfDay = LocalDate.now().atStartOfDay();
        LocalDateTime startOfMonth = LocalDate.now().withDayOfMonth(1).atStartOfDay();

        Integer todayOrders = salesOrders.countNonCancelledSince(startOfDay);
        BigDecimal todayRevenue = salesOrders.sumRevenueSince(startOfDay);

        Integer monthOrders = salesOrders.countNonCancelledSince(startOfMonth);
        BigDecimal monthRevenue = salesOrders.sumRevenueSince(startOfMonth);

        BigDecimal avg = BigDecimal.ZERO;
        if (monthOrders != null && monthOrders > 0 && monthRevenue != null) {
            avg = monthRevenue.divide(BigDecimal.valueOf(monthOrders), 2, RoundingMode.HALF_UP);
        }

        return DashboardResponse.SalesMetrics.builder()
                .totalOrdersToday(todayOrders == null ? 0 : todayOrders)
                .revenueToday(todayRevenue == null ? BigDecimal.ZERO : todayRevenue)
                .totalOrdersThisMonth(monthOrders == null ? 0 : monthOrders)
                .revenueThisMonth(monthRevenue == null ? BigDecimal.ZERO : monthRevenue)
                .averageOrderValueThisMonth(avg)
                .build();
    }

    private List<DashboardResponse.LowStockItem> buildLowStockList() {
        User user = securityUtils.getCurrentUser();
        List<Product> lowStock;

        if (user.getRole().getName().equals("INVENTORY_STAFF") && user.getDepartment() != null) {
            lowStock = products.findLowStockProducts().stream()
                    .filter(p -> p.getCategory() != null && p.getCategory().getName().equals(user.getDepartment()))
                    .collect(Collectors.toList());
        } else {
            lowStock = products.findLowStockProducts();
        }

        return lowStock.stream()
                .limit(10)
                .map(p -> DashboardResponse.LowStockItem.builder()
                        .productId(p.getId())
                        .sku(p.getSku())
                        .productName(p.getName())
                        .currentStock(p.getQuantityOnHand())
                        .reorderPoint(p.getReorderPoint())
                        .build())
                .collect(Collectors.toList());
    }

    private List<DashboardResponse.RecentOrder> buildRecentOrders() {
        List<SalesOrder> recent = salesOrders.findTop10ByOrderByOrderDateDesc();
        return recent.stream()
                .map(o -> DashboardResponse.RecentOrder.builder()
                        .orderId(o.getId())
                        .orderNumber(o.getOrderNumber())
                        .customerName(o.getCustomer() != null ? o.getCustomer().getName() : "Walk-in")
                        .totalAmount(o.getTotalAmount())
                        .status(o.getStatus() != null ? o.getStatus().name() : null)
                        .orderDate(o.getOrderDate() != null ? o.getOrderDate().toString() : null)
                        .build())
                .collect(Collectors.toList());
    }
}