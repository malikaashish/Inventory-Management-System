package com.inventory.service;

import com.inventory.dto.response.DashboardResponse;
import com.inventory.entity.Product;
import com.inventory.entity.SalesOrder;
import com.inventory.repository.ProductRepository;
import com.inventory.repository.SalesOrderRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
public class DashboardService {

    private final ProductRepository products;
    private final SalesOrderRepository salesOrders;

    @Transactional(readOnly = true)
    public DashboardResponse getDashboard(String range) {
        DashboardResponse.InventoryMetrics inv = buildInventoryMetrics();
        DashboardResponse.SalesMetrics sales = buildSalesMetrics();
        List<DashboardResponse.LowStockItem> lowStock = buildLowStockList();
        List<DashboardResponse.RecentOrder> recent = buildRecentOrders();
        List<DashboardResponse.ChartData> chartData = buildChartData(range);
        List<DashboardResponse.PieChartData> pieData = buildPieChartData(); // <-- NEW

        return DashboardResponse.builder()
                .inventoryMetrics(inv)
                .salesMetrics(sales)
                .lowStockItems(lowStock)
                .recentOrders(recent)
                .salesChart(chartData)
                .departmentSales(pieData) // <-- NEW
                .build();
    }

    private List<DashboardResponse.ChartData> buildChartData(String range) {
        LocalDateTime startDate = switch (range.toLowerCase()) {
            case "week" -> LocalDateTime.now().minusWeeks(1);
            case "month" -> LocalDateTime.now().minusMonths(1);
            case "year" -> LocalDateTime.now().minusYears(1);
            default -> LocalDateTime.now().minusDays(1);
        };

        List<Object[]> results = salesOrders.findSalesStatsByDateRange(startDate);
        
        return results.stream().map(row -> DashboardResponse.ChartData.builder()
                .date(row[0].toString())
                .orderCount(((Number) row[1]).intValue())
                .revenue((BigDecimal) row[2])
                .build()
        ).toList();
    }

    // NEW: Pie Chart Data Builder
    private List<DashboardResponse.PieChartData> buildPieChartData() {
        List<Object[]> results = salesOrders.findSalesByDepartment();
        return results.stream().map(row -> DashboardResponse.PieChartData.builder()
                .name(row[0] != null ? row[0].toString() : "Unassigned")
                .value((BigDecimal) row[1])
                .build()
        ).toList();
    }

    private DashboardResponse.InventoryMetrics buildInventoryMetrics() {
        List<Product> all = products.findByIsActiveTrue();

        int totalProducts = all.size();
        int totalQty = all.stream().mapToInt(p -> p.getQuantityOnHand() == null ? 0 : p.getQuantityOnHand()).sum();
        int outOfStock = (int) all.stream().filter(p -> (p.getQuantityOnHand() == null ? 0 : p.getQuantityOnHand()) == 0).count();

        BigDecimal totalValue = products.calculateTotalInventoryValue();
        Integer lowStockCount = products.countLowStockProducts();

        return DashboardResponse.InventoryMetrics.builder()
                .totalProducts(totalProducts)
                .totalQuantity(totalQty)
                .totalInventoryValue(totalValue == null ? BigDecimal.ZERO : totalValue)
                .lowStockCount(lowStockCount == null ? 0 : lowStockCount)
                .outOfStockCount(outOfStock)
                .build();
    }

    private DashboardResponse.SalesMetrics buildSalesMetrics() {
        LocalDateTime startOfDay = LocalDate.now().atStartOfDay();
        LocalDateTime startOfMonth = LocalDate.now().withDayOfMonth(1).atStartOfDay();

        Integer todayOrders = salesOrders.countNonCancelledSince(startOfDay);
        BigDecimal todayRevenue = salesOrders.sumRevenueSince(startOfDay);

        Integer monthOrders = salesOrders.countNonCancelledSince(startOfMonth);
        BigDecimal monthRevenue = salesOrders.sumRevenueSince(startOfMonth);

        BigDecimal avg = BigDecimal.ZERO;
        if (monthOrders != null && monthOrders > 0 && monthRevenue != null) {
            avg = monthRevenue.divide(BigDecimal.valueOf(monthOrders), 2, RoundingMode.HALF_UP);
        }

        return DashboardResponse.SalesMetrics.builder()
                .totalOrdersToday(todayOrders == null ? 0 : todayOrders)
                .revenueToday(todayRevenue == null ? BigDecimal.ZERO : todayRevenue)
                .totalOrdersThisMonth(monthOrders == null ? 0 : monthOrders)
                .revenueThisMonth(monthRevenue == null ? BigDecimal.ZERO : monthRevenue)
                .averageOrderValueThisMonth(avg)
                .build();
    }

    private List<DashboardResponse.LowStockItem> buildLowStockList() {
        return products.findLowStockProducts().stream()
                .limit(10)
                .map(p -> DashboardResponse.LowStockItem.builder()
                        .productId(p.getId())
                        .sku(p.getSku())
                        .productName(p.getName())
                        .currentStock(p.getQuantityOnHand())
                        .reorderPoint(p.getReorderPoint())
                        .build())
                .toList();
    }

    private List<DashboardResponse.RecentOrder> buildRecentOrders() {
        List<SalesOrder> recent = salesOrders.findTop10ByOrderByOrderDateDesc();
        return recent.stream()
                .map(o -> DashboardResponse.RecentOrder.builder()
                        .orderId(o.getId())
                        .orderNumber(o.getOrderNumber())
                        .customerName(o.getCustomer() != null ? o.getCustomer().getName() : "Walk-in")
                        .totalAmount(o.getTotalAmount())
                        .status(o.getStatus() != null ? o.getStatus().name() : null)
                        .orderDate(o.getOrderDate() != null ? o.getOrderDate().toString() : null)
                        .build())
                .toList();
    }
}